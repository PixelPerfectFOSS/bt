const fs = require("fs-extra");  
const path = require("path");
const unixify = require("unixify");
const glob = require("glob-promise");
const Font = require("fonteditor-core").Font;
const fonteditorcore = require("./fonteditorcore");

function requireUncached(module) {
    delete require.cache[require.resolve(module)];
    return require(module);
}

const fontsPath = path.resolve("./Fonts");
const fontsListPath = path.resolve("./.data/fonts.json");
const fontsConfigPath = path.resolve("./.data/fonts.config.json");
const fontsOutputPath = path.resolve("./HTML/fonts.css");

async function fontParams(fontPath) {
    function processName(str){
        return str.replace(/[ \`\'\"]+/g, "_");
    }

    const buffer = await fs.readFile(fontPath);
    const format = path.extname(fontPath).substring(1);
    const font = Font.create(buffer, { type: format });
    const fontObject = font.get();
    const fontNameParams = fontObject["name"];
    const family = processName(fontNameParams.preferredFamily || fontNameParams.fontFamily || "Unnamed");
    const subFamily = processName(fontNameParams.preferredSubFamily || fontNameParams.fontSubFamily || "Regular");
    const name = `${family}_${subFamily}`;

    return { name, family, subFamily };
}

async function init() {
    if (!(await fs.pathExists(fontsConfigPath))){
        await fs.writeJSON(fontsConfigPath, {});
    }

    const pattern = `${unixify(fontsPath)}/**/*.{ttf,otf}`;
    const files = await glob.promise(pattern);
    const fonts = {};
    for (const fontPath of files) {
        const fontName = path.basename(fontPath);
        const params = await fontParams(fontPath);
        fonts[fontName] = params;
    }
    await fs.writeJSON(fontsListPath, fonts);
}

async function update() {
    await init();
}

async function fontsList(req = {}) {
    if (await fs.pathExists(fontsListPath)) {
        const fonts = requireUncached(fontsListPath);
        return {
            ok: true,
            message: "",
            data: { fonts: fonts }
        };
    }
    else {
        return {
            ok: false,
            message: `${fontsListPath} not found`
        };
    }
}

async function fontsConfig(req = {}) {
    let config = {};
    if (await fs.pathExists(fontsConfigPath)) {
        config = requireUncached(fontsConfigPath) || {};
    }

    return {
        ok: true,
        message: "",
        data: {
            config: config
        }
    };
}

async function generateFonts(req) {
    console.log("Font generator is running...");

    try {
        const config = req.config;
        const comment = "/* Generated by BT Font Generator */\n";
    
        let css = comment;
        for (const fontFile of Object.keys(config)) {
            const fontOptions = config[fontFile];
            if (fontOptions.engine !== "fec") {
                console.log(`Warning: engine ${fontOptions.engine} is not supported, using default engine (fonteditor-core)`);
            }
    
            const fontDataUrl = await fonteditorcore.generate(fontsPath, fontFile, fontOptions);
    
            // TODO: validate fontOptions.fontname length
            const fontFace = 
`@font-face {
    font-family: "${fontOptions.fontname}";
    font-weight: normal;
    font-style: normal;
    src: url("${fontDataUrl}") format("woff");
}
`;
            css += fontFace;
        }
        console.log("Done");

        throw new Error("Fuck!");
    
        await fs.writeFile(fontsOutputPath, css);
        await fs.writeJSON(fontsConfigPath, config);
        return {
            ok: true,
            message: "",
            output: css
        }
    }
    catch(e) {
        console.log(e.message);
        return {
            ok: false,
            message: e.message
        }
    }
}

module.exports = {
    init,
    update,
    fontsList,
    fontsConfig,
    generateFonts
};
