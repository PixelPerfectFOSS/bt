const fs = require("fs-extra");  
const path = require("path");
const childProcess = require("child_process");
const unixify = require("unixify");
const glob = require("glob-promise");
const Font = require("fonteditor-core").Font;

function requireUncached(module) {
    delete require.cache[require.resolve(module)];
    return require(module);
}

const fontsPath = path.resolve("./Fonts");
const fontsListPath = path.resolve("./.data/fonts.json");
const fontsConfigPath = path.resolve("./.data/fonts.config.json");
const fontsOutputPath = path.resolve("./HTML/fonts.css");

const comment = "/* Generated by BT Font Generator */\n";

// TODO: async
function genGlyphhanger(fontPath, options) {
    const defaultWhitelist = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890.,:;!?-+*/=><@#�$%^&()[]{}|";
    const whitelist = options.text || defaultWhitelist;

    function strToHex(str) {
        let result = "";
        for (let i = 0; i < str.length; i++) {
            result += "U+" + str.charCodeAt(i).toString(16) + ",";
        }
        return result;
    }

    const command = `glyphhanger --whitelist=${strToHex(whitelist)} --formats=woff --subset=${fontPath}`;
    console.log(command);

    childProcess.execSync(command, function(err, stdout, stderr) {
        if (err) {
            return console.log(err);
        }
    });
    
    const fontName = path.parse(fontPath).name;

    const woffFile = path.join(fontsPath, `${fontName}-subset.woff`);
    const woffData = fs.readFileSync(woffFile);
    const woffDataBase64 = woffData.toString("base64");

    const css = `@font-face {
    font-family: "${options.fontname}";
    font-weight: normal;
    font-style: normal;
    src: url(data:font/woff;charset=utf-8;base64,${woffDataBase64}) format("woff");
}
`;
    
    return css;
}

async function fontParams(fontPath) {
    function processName(str){
        return str.replace(/[ \`\'\"]+/g, "_");
    }

	const buffer = await fs.readFile(fontPath);
	const format = path.extname(fontPath).substring(1);
	const font = Font.create(buffer, { type: format });
	const fontObject = font.get();
	const fontNameParams = fontObject["name"];
	const family = processName(fontNameParams.preferredFamily || fontNameParams.fontFamily || "Unnamed");
	const subFamily = processName(fontNameParams.preferredSubFamily || fontNameParams.fontSubFamily || "Regular");
	const name = `${family}_${subFamily}`;

	return { name, family, subFamily };
}

async function init() {
    console.log("Font Generator init");

	if (!(await fs.pathExists(fontsConfigPath))){
		await fs.writeJSON(fontsConfigPath, {});
	}

    const pattern = `${unixify(fontsPath)}/**/*.{ttf,otf}`;
    const files = await glob.promise(pattern);
    const fonts = {};
    for (const fontPath of files) {
        const fontName = path.basename(fontPath);
        const params = await fontParams(fontPath);
        fonts[fontName] = params;
    }
    await fs.writeJSON(fontsListPath, fonts);
}

async function fontsList(req = {}) {
    if (await fs.pathExists(fontsListPath)) {
        const fonts = requireUncached(fontsListPath);
        return {
            ok: true,
            message: "",
            data: { fonts: fonts }
        };
    }
    else {
        return {
            ok: false,
            message: `${fontsListPath} not found`
        };
    }
}

async function fontsConfig(req = {}) {
    if (await fs.pathExists(fontsConfigPath)) {
        const config = requireUncached(fontsConfigPath);
        return {
            ok: true,
            message: "",
            data: {
                config: config
            }
        };
    }
    else {
        return {
            ok: false,
            message: `${fontsConfigPath} not found`
        };
    }
}

async function generateFonts(req) {
    console.log("Generate fonts");
    const config = req.config;
    console.log(config);

    let css = comment;
    Object.keys(config).forEach(function(key) {
        const fontPath = path.join(fontsPath, key);
        const fontOptions = config[key];
        css += genGlyphhanger(fontPath, fontOptions);
    });

    await fs.writeFile(fontsOutputPath, css);
    await fs.writeJSON(fontsConfigPath, config);
    return {};
}

module.exports = {
    init,
    fontsList,
    fontsConfig,
    generateFonts
};
