const fs = require("fs-extra");  
const util = require("util");
const path = require("path");
const unixify = require("unixify");
const glob = require("glob-promise");
//const template = require("es6-template-strings");
const compile = require("es6-template-strings/compile");
const resolveToString = require("es6-template-strings/resolve-to-string");
const Font = require("fonteditor-core").Font;

function requireUncached(module) {
    delete require.cache[require.resolve(module)];
    return require(module);
}

// TODO: update to work with Banny Tools projects

const defaultTemplate = "font.template.css";
const defaultWhitelist = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890.,:;!?-+*/=><@#�$%^&()[]{}|";

function processFont(fontsDir, configDir, font) {
    const fontFamily = font.family || "";
    const fontFile = path.join(fontsDir, font.file || "");
    const whitelist = font.whitelist || defaultWhitelist;
    const cssTemplateFilename = path.join(configDir, font.cssTemplate || defaultTemplate);
    
    console.log(whitelist);

    function strToHex(str) {
        let result = "";
        for (let i = 0; i < str.length; i++) {
            result += "U+" + str.charCodeAt(i).toString(16) + ",";
        }
        return result;
    }

    const glyphhanger = "glyphhanger";
    const commandTemplate = "%s --whitelist=%s --formats=woff --subset=%s";
    const cssTemplate = compile(fs.readFileSync(cssTemplateFilename, "utf8"));
    const command = util.format(commandTemplate, glyphhanger, strToHex(whitelist), fontFile);

    console.log(command);

    require("child_process").execSync(command, function(err, stdout, stderr) {
        if (err) {
            return console.log(err);
        }
    });
    
    var woffFile = util.format(path.join(fontsDir, "%s-subset.woff"), path.parse(fontFile).name);
    var woffData = fs.readFileSync(woffFile);
    var woffDataBase64 = woffData.toString("base64");
    var css = resolveToString(cssTemplate, {font_family: fontFamily, font_data: woffDataBase64});
    
    return css;
}

const comment = "/* Generated by webfontgen.js */\n";

function generateFonts() {
    const fonts = requireUncached(path.resolve("./src/fonts.json"));
    const fontsDir = path.resolve("./fonts");
    const configDir = path.resolve("./src");
    const outputDir = path.resolve("./");
            
    var css = comment;
    Object.keys(fonts).forEach(function(key) {
        css += processFont(fontsDir, configDir, fonts[key]);
    });

    fs.writeFile(path.join(outputDir, "fonts.css"), css, function(err) {
        if (err)
            return console.log(err);
        else
            console.log("Success!");
    });
}

//

const fontsPath = path.resolve("./Fonts");
const fontsListPath = path.resolve("./.data/fonts.json");
const fontsConfigPath = path.resolve("./.data/fonts.config.json");

async function fontParams(fontPath) {
    function processName(str){
        return str.replace(/[ \`\'\"]+/g, "_");
    }

	const buffer = await fs.readFile(fontPath);
	const format = path.extname(fontPath).substring(1);
	const font = Font.create(buffer, { type: format });
	const fontObject = font.get();
	const fontNameParams = fontObject["name"];
	const family = processName(fontNameParams.preferredFamily || fontNameParams.fontFamily || "Unnamed");
	const subFamily = processName(fontNameParams.preferredSubFamily || fontNameParams.fontSubFamily || "Regular");
	const name = `${family}_${subFamily}`;

	return { name, family, subFamily };
}

async function init() {
    console.log("Font Generator init");

	if (!(await fs.pathExists(fontsConfigPath))){
		await fs.writeJSON(fontsConfigPath, {});
	}

    const pattern = `${unixify(fontsPath)}/**/*.{ttf,otf}`;
    const files = await glob.promise(pattern);
    const fonts = {};
    for (const fontPath of files) {
        const fontName = path.basename(fontPath);
        const params = await fontParams(fontPath);
        fonts[fontName] = params;
    }
    await fs.writeJSON(fontsListPath, fonts);
}

async function fontsList(req = {}) {
    if (await fs.pathExists(fontsListPath)) {
        const fonts = requireUncached(fontsListPath);
        return {
            ok: true,
            message: "",
            data: { fonts: fonts }
        };
    }
    else {
        return {
            ok: false,
            message: ".data/fonts.json not found"
        };
    }
}

async function fontsConfig(req = {}) {
    if (await fs.pathExists(fontsConfigPath)) {
        const config = requireUncached(fontsConfigPath);
        return {
            ok: true,
            message: "",
            data: {
                config: config
            }
        };
    }
    else {
        return {
            ok: false,
            message: ".data/fonts.config.json not found"
        };
    }
}

async function generateFonts(req) {
    const config = req.config;
    console.log(req);
    return {};
}

module.exports = {
    init,
    fontsList,
    fontsConfig,
    generateFonts
};
